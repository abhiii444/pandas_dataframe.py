# -*- coding: utf-8 -*-
"""Pandas DataFrame.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OFlCmPBCgvYYuwxWz5oGm05XVVuu5M_P

### Pandas DataFrame
"""

import numpy as np
import pandas as pd

df = pd.DataFrame({
    'Population': [35.467, 63.951, 80.94 , 60.665, 127.061, 64.511, 318.523],
    'GDP': [
        1785387,
        2833687,
        3874437,
        2167744,
        4602367,
        2950039,
        17348075
    ],
    'Surface Area': [
        9984670,
        640679,
        357114,
        301336,
        377930,
        242495,
        9525067
    ],
    'HDI': [
        0.913,
        0.888,
        0.916,
        0.873,
        0.891,
        0.907,
        0.915
    ],
    'Continent': [
        'America',
        'Europe',
        'Europe',
        'Europe',
        'Asia',
        'Europe',
        'America'
    ]
}, columns=['Population', 'GDP', 'Surface Area', 'HDI', 'Continent'])

df

df.index= ['Canada' , 'France' , 'Germany','Italy' ,'Japan' ,'US' , 'UK']

df

df.info()

df.size

df.shape

df.describe()

df.dtypes

df.dtypes.value_counts()

"""### Indexing ,  selection and slicing"""

df

df.loc['Canada']

df.iloc[-1]

df['Population']

"""### Note that the index of the returned series is the same as the DataFrame one. And its name is the name of the column. If you're workingf on the a notebook and want to see a more DataFrame like format you can use the to_frame method :"""

df['Population'].to_frame()

"""### Multiples column can also be selected similary to numpy and series"""

df[['Population', 'GDP']]

"""### In this Case, the result is another DataFrame. Silicing works differently, it acts at "row level",and can be counter intuitive"""

df[1:3]

"""### Row level selection works better with the loc and iloc which are recommended  over regular  "direct slicing "(df[:]). loc selects rows matching  the given index"""

df.loc['Italy']

df.loc['France':'Italy']

df.loc['France':'Italy', 'Population']

df.loc['France':'Italy', ['Population', 'GDP']]

df

df.iloc[0]

df.iloc[-1]

df.iloc[[0,1,-1]]

df.iloc[1:3]

df.iloc[1:3,3]

df.iloc[1:3,[0,3]]

df.iloc[1:3 , 1:3]

"""### RECOMMENDED : Always use loc and iloc to reduce ambiguity , specially with DataFrames with numeric indexes.

##Conditional selection ( boolean arrays )

###We saw conditional selection applied to Series and it'll work in the same way for DataFrames. After all, a DataFrame is a collection of Series
"""

df

df['Population'] >70

df.loc[df['Population']>70]

"""### The Boolean matching is done at index level , so you can filter by any row, as long as it contains the right indexes.Column selection still works as expected"""

df.loc[df['Population']>70,'Population']

df.loc[df['Population']>70,['Population', 'GDP']]

"""### Dropping stuff

Opposed to the concept of selection , we have "dropping'. Instead of pointing out which values you'd like to select you could point which ones you'd like to drop
"""

df.drop('Canada')

df.drop(['Canada' , 'Japan'])

df.drop(columns=['Population','HDI'])

df.drop(['Canada' , 'Japan'], axis=0)

df.drop(['Population' , 'HDI'], axis=1)

df.drop(['Population' , 'HDI'], axis='columns')

df.drop(['Canada' , 'Japan'], axis='rows')

"""### Operations"""

df[['Population','GDP']]

df[['Population','GDP']]/100

"""### Operations with Series work at a column level,broadcasting down the rows ( which can be counter intuitive)."""

crisis = pd.Series([-1000000,-0.3],index=['GDP' ,"HDI"])

crisis

df[['GDP','HDI']]

df[['GDP','HDI']]+crisis

"""### Modifying DataFrame

###Adding new column
"""

langs =pd.Series(['French','Italian','German'],index=['France','Italy','Germany'],name='Language')

langs

df['Language']=langs

df

"""###Replacing values per column"""

df['Language'] = 'English'

df

"""###Renaming columns"""

df.rename(columns={'HDI':'Human Development Index','Anual Popcorn Consumption':'APC'},index={'US':'United States','UK':'United Kingdom'})

df.rename(index=str.upper)

df.rename(index=lambda x:x.lower())